<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Intermediate - Learning Hub</title>
    <link rel="stylesheet" href="jav.css">
</head>
<body>

    <!-- Navigation Bar -->
    <header>
      <h2><span class="blue">Learning</span><span class="orange">Hub</span></h2>
        <nav>
            <ul id="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="about.html">About</a></li>
                <li><a href="course.html" class="active">Courses</a></li>
                <li><a href="resources.html ">Resources</a></li>
            </ul>
            <div class="hamburger" id="hamburger">☰</div>
        </nav>
    </header>
    
          <div class="back-button">
        <a href="course.html"><i class="fas fa-arrow-left"></i> Back</a>
      </div>
    
    <!-- Search Bar -->
    <div class="search-container">
        <input type="text" id="searchBar" placeholder="Search lessons..." onkeyup="searchLessons()">
    </div>
 
    <!-- Lesson Sections -->
    <main id="lessons">
        <section id="oop" class="lesson">
    <h2>Introduction to Object-Oriented Programming (OOP) in Java</h2>

    <p>Object-Oriented Programming (OOP) is a programming paradigm based on the concept of objects, which contain both data (attributes) and methods (behaviors). Java is a fully object-oriented language that follows OOP principles to organize and manage code efficiently.</p>

    <h3>Key OOP Concepts</h3>

    <h4>1. Classes and Objects</h4>
    <p>A <strong>class</strong> is a blueprint for creating objects, while an <strong>object</strong> is an instance of a class.</p>

    <h4>Example: Creating a Class and an Object</h4>
    <pre><code>class Car {
    String brand;
    int speed;

    void drive() {
        System.out.println(brand + " is driving at " + speed + " km/h");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car(); // Creating an object
        myCar.brand = "Toyota";
        myCar.speed = 100;
        myCar.drive();
    }
}</code></pre>

    <h4>2. Encapsulation</h4>
    <p>Encapsulation is the practice of keeping data private and providing controlled access using getters and setters.</p>

    <h4>Example: Encapsulation in Java</h4>
    <pre><code>class Person {
    private String name;

    // Getter method
    public String getName() {
        return name;
    }

    // Setter method
    public void setName(String newName) {
        this.name = newName;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");
        System.out.println("Person's name: " + person.getName());
    }
}</code></pre>

    <h4>3. Inheritance</h4>
    <p>Inheritance allows one class to inherit properties and methods from another class, promoting code reusability.</p>

    <h4>Example: Inheritance in Java</h4>
    <pre><code>class Animal {
    void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Woof! Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.makeSound(); // Inherited method
        myDog.bark();
    }
}</code></pre>

    <h4>4. Polymorphism</h4>
    <p>Polymorphism allows a method to have different behaviors based on the object that calls it.</p>

    <h4>Example: Method Overriding</h4>
    <pre><code>class Animal {
    void makeSound() {
        System.out.println("Some animal sound");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow! Meow!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Cat();
        myAnimal.makeSound(); // Calls the overridden method in Cat
    }
}</code></pre>

    <h4>5. Abstraction</h4>
    <p>Abstraction allows you to hide implementation details and only expose essential features.</p>

    <h4>Example: Abstract Class</h4>
    <pre><code>abstract class Vehicle {
    abstract void start();
}

class Car extends Vehicle {
    void start() {
        System.out.println("Car is starting...");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle myCar = new Car();
        myCar.start();
    }
}</code></pre>

    <p>By understanding these OOP principles, you can create structured, reusable, and maintainable code. </p>
</section>

        <section id="class-attributes" class="lesson">
    <h2>Understanding Class Attributes in Java</h2>

    <p>Class attributes (also known as fields or instance variables) are variables that belong to an object and store data related to that object. They define the properties of a class and can have different access modifiers.</p>

    <h3>Declaring Class Attributes</h3>
    <p>Class attributes are typically declared at the beginning of a class.</p>

    <h4>Example: Declaring and Accessing Class Attributes</h4>
    <pre><code>class Car {
    String brand;
    int speed;
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.brand = "Toyota";
        myCar.speed = 120;

        System.out.println("Brand: " + myCar.brand);
        System.out.println("Speed: " + myCar.speed + " km/h");
    }
}</code></pre>

    <h3>Instance vs. Static Attributes</h3>
    <p>Class attributes can be either instance attributes (specific to each object) or static attributes (shared among all objects of the class).</p>

    <h4>Example: Instance vs. Static Attributes</h4>
    <pre><code>class Car {
    String brand;  // Instance attribute
    static int wheels = 4; // Static attribute
}

public class Main {
    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = new Car();
        
        car1.brand = "Honda";
        car2.brand = "Ford";

        System.out.println("Car 1: " + car1.brand + ", Wheels: " + Car.wheels);
        System.out.println("Car 2: " + car2.brand + ", Wheels: " + Car.wheels);
    }
}</code></pre>

    <h3>Access Modifiers</h3>
    <p>Access modifiers define the visibility of class attributes.</p>
    <ul>
        <li><strong>private</strong> - Accessible only within the class.</li>
        <li><strong>public</strong> - Accessible from anywhere.</li>
        <li><strong>protected</strong> - Accessible within the same package and subclasses.</li>
        <li><strong>default (no modifier)</strong> - Accessible within the same package.</li>
    </ul>

    <h4>Example: Using Private Attributes with Getters and Setters</h4>
    <pre><code>class Person {
    private String name;

    // Getter
    public String getName() {
        return name;
    }

    // Setter
    public void setName(String newName) {
        this.name = newName;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");
        System.out.println("Name: " + person.getName());
    }
}</code></pre>

    <h3>Final Attributes</h3>
    <p>Attributes marked as <code>final</code> cannot be changed after initialization.</p>

    <h4>Example: Using Final Attributes</h4>
    <pre><code>class Car {
    final String brand = "Toyota";
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        System.out.println("Brand: " + myCar.brand);

        // This line would cause an error:
        // myCar.brand = "Honda"; 
    }
}</code></pre>

    <p>Understanding class attributes is essential for structuring object-oriented programs.
</section>

        <section id="getters-and-setters" class="lesson">
    <h2>Understanding Getters and Setters in Java</h2>

    <p>Getters and setters are methods that provide controlled access to class attributes. They are used to enforce encapsulation by making attributes private and exposing only the necessary functionality.</p>

    <h3>Why Use Getters and Setters?</h3>
    <ul>
        <li>Encapsulation: Protects data from direct modification.</li>
        <li>Validation: Allows logic to be added when setting values.</li>
        <li>Readability: Provides a clear way to access and modify data.</li>
    </ul>

    <h3>Creating Getters and Setters</h3>
    <p>By convention, getter methods start with <code>get</code>, and setter methods start with <code>set</code>.</p>

    <h4>Example: Basic Getters and Setters</h4>
    <pre><code>class Person {
    private String name;

    // Getter method
    public String getName() {
        return name;
    }

    // Setter method
    public void setName(String newName) {
        this.name = newName;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice"); // Setting value using setter
        System.out.println("Name: " + person.getName()); // Getting value using getter
    }
}</code></pre>

    <h3>Using Getters and Setters for Data Validation</h3>
    <p>Setters can include validation logic to ensure data integrity.</p>

    <h4>Example: Validation in Setters</h4>
    <pre><code>class BankAccount {
    private double balance;

    // Getter
    public double getBalance() {
        return balance;
    }

    // Setter with validation
    public void setBalance(double amount) {
        if (amount >= 0) {
            balance = amount;
        } else {
            System.out.println("Balance cannot be negative!");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.setBalance(500.00);
        System.out.println("Balance: $" + account.getBalance());

        account.setBalance(-100); // Invalid operation
    }
}</code></pre>

    <h3>Readonly Attributes with Getters Only</h3>
    <p>Sometimes, attributes should only be readable and not modifiable.</p>

    <h4>Example: Readonly Attribute</h4>
    <pre><code>class Car {
    private final String brand = "Toyota";

    // Getter only, no setter
    public String getBrand() {
        return brand;
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        System.out.println("Brand: " + myCar.getBrand());

        // This line would cause an error:
        // myCar.setBrand("Honda");
    }
}</code></pre>

    <h3>Auto-Generating Getters and Setters</h3>
    <p>Many IDEs (like IntelliJ IDEA and Eclipse) can automatically generate getters and setters.</p>

    <h4>Example: Auto-Generated Getters and Setters in IntelliJ</h4>
    <ol>
        <li>Right-click inside the class.</li>
        <li>Select <strong>Generate</strong> → <strong>Getter and Setter</strong>.</li>
        <li>Choose the attributes and click <strong>OK</strong>.</li>
    </ol>

    <p>Getters and setters are crucial for data protection and control. 
</section>

        <section id="constructors" class="lesson">
    <h2>Understanding Constructors in Java</h2>

    <p>A constructor is a special method used to initialize objects. It is automatically called when an object is created and is used to set initial values for attributes.</p>

    <h3>Key Features of Constructors</h3>
    <ul>
        <li>A constructor has the same name as the class.</li>
        <li>It does not have a return type (not even <code>void</code>).</li>
        <li>It runs automatically when an object is instantiated.</li>
    </ul>

    <h3>Creating a Constructor</h3>
    <h4>Example: Basic Constructor</h4>
    <pre><code>class Car {
    String brand;
    int speed;

    // Constructor
    public Car(String brand, int speed) {
        this.brand = brand;
        this.speed = speed;
    }

    void displayInfo() {
        System.out.println("Brand: " + brand + ", Speed: " + speed + " km/h");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Toyota", 120);
        myCar.displayInfo();
    }
}</code></pre>

    <h3>Types of Constructors</h3>
    <h4>1. Default Constructor</h4>
    <p>If no constructor is defined, Java provides a default constructor with no parameters.</p>

    <pre><code>class Person {
    String name;

    // Default Constructor
    public Person() {
        name = "Unknown";
    }

    void display() {
        System.out.println("Name: " + name);
    }
}

public class Main {
    public static void main(String[] args) {
        Person person1 = new Person();
        person1.display();
    }
}</code></pre>

    <h4>2. Parameterized Constructor</h4>
    <p>A constructor with parameters allows setting initial values when creating an object.</p>

    <pre><code>class Student {
    String name;
    int age;

    // Parameterized Constructor
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

public class Main {
    public static void main(String[] args) {
        Student student1 = new Student("Alice", 20);
        student1.displayInfo();
    }
}</code></pre>

    <h4>3. Constructor Overloading</h4>
    <p>Multiple constructors can be created with different parameters, allowing flexibility in object creation.</p>

    <pre><code>class Book {
    String title;
    String author;

    // Constructor with one parameter
    public Book(String title) {
        this.title = title;
        this.author = "Unknown";
    }

    // Constructor with two parameters
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    void displayInfo() {
        System.out.println("Title: " + title + ", Author: " + author);
    }
}

public class Main {
    public static void main(String[] args) {
        Book book1 = new Book("Java Basics");
        Book book2 = new Book("Advanced Java", "John Doe");

        book1.displayInfo();
        book2.displayInfo();
    }
}</code></pre>

    <h3>Using "this" Keyword</h3>
    <p>The <code>this</code> keyword is used to refer to the current object's instance variables.</p>

    <pre><code>class Employee {
    String name;
    int salary;

    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }

    void display() {
        System.out.println("Employee: " + this.name + ", Salary: $" + this.salary);
    }
}

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("Bob", 50000);
        emp.display();
    }
}</code></pre>

    <p>Constructors are essential for initializing objects efficiently.</p>
</section>

        <section id="value-and-reference-types" class="lesson">
    <h2>Understanding Value and Reference Types in Java</h2>

    <p>In Java, variables store data in two main ways: <strong>value types</strong> and <strong>reference types</strong>. Understanding the difference between them is crucial for managing memory and data correctly.</p>

    <h3>1. Value Types (Primitive Data Types)</h3>
    <p>Value types store the actual data directly in memory. When a value type variable is assigned to another, a copy of the value is made.</p>

    <h4>Example: Value Type Assignment</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        int a = 10;
        int b = a; // Copies the value of 'a' into 'b'

        System.out.println("Before changing b:");
        System.out.println("a: " + a + ", b: " + b);

        b = 20; // Changing 'b' does not affect 'a'

        System.out.println("After changing b:");
        System.out.println("a: " + a + ", b: " + b);
    }
}</code></pre>

    <h3>2. Reference Types (Objects and Arrays)</h3>
    <p>Reference types store a memory address (reference) pointing to an object rather than storing the actual data.</p>

    <h4>Example: Reference Type Assignment</h4>
    <pre><code>class Person {
    String name;
}

public class Main {
    public static void main(String[] args) {
        Person person1 = new Person();
        person1.name = "Alice";

        Person person2 = person1; // Both refer to the same object

        System.out.println("Before changing person2:");
        System.out.println("person1 name: " + person1.name);
        System.out.println("person2 name: " + person2.name);

        person2.name = "Bob"; // Changing person2 also affects person1

        System.out.println("After changing person2:");
        System.out.println("person1 name: " + person1.name);
        System.out.println("person2 name: " + person2.name);
    }
}</code></pre>

    <h3>3. Key Differences Between Value and Reference Types</h3>
    <table border="1">
        <tr>
            <th>Value Type</th>
            <th>Reference Type</th>
        </tr>
        <tr>
            <td>Stores the actual value</td>
            <td>Stores a reference (memory address) to an object</td>
        </tr>
        <tr>
            <td>Changes affect only the specific variable</td>
            <td>Changes affect all references to the object</td>
        </tr>
        <tr>
            <td>Used for primitive types (int, double, char, etc.)</td>
            <td>Used for objects (arrays, classes, etc.)</td>
        </tr>
    </table>

    <h3>4. Example: Value vs. Reference in Arrays</h3>
    <pre><code>public class Main {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = arr1; // arr2 refers to the same array as arr1

        System.out.println("Before modifying arr2:");
        System.out.println("arr1[0]: " + arr1[0]);
        System.out.println("arr2[0]: " + arr2[0]);

        arr2[0] = 99; // Changes affect both arr1 and arr2

        System.out.println("After modifying arr2:");
        System.out.println("arr1[0]: " + arr1[0]);
        System.out.println("arr2[0]: " + arr2[0]);
    }
}</code></pre>

    <h3>5. Preventing Unintended Changes in Reference Types</h3>
    <p>If you want to modify an object without affecting the original reference, create a new object.</p>

    <h4>Example: Creating a New Object</h4>
    <pre><code>class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person1 = new Person("Alice");
        Person person2 = new Person(person1.name); // Creates a separate object

        person2.name = "Bob"; // Modifies only person2

        System.out.println("person1 name: " + person1.name);
        System.out.println("person2 name: " + person2.name);
    }
}</code></pre>

    <p>Understanding value and reference types helps in managing data and avoiding unintended changes in Java programs.
</section>

        <section id="math-class" class="lesson">
    <h2>Understanding the Math Class in Java</h2>

    <p>The <code>Math</code> class in Java provides useful mathematical functions and constants to perform calculations such as rounding, exponentiation, trigonometry, and random number generation.</p>

    <h3>1. Math Constants</h3>
    <p>The <code>Math</code> class includes two commonly used mathematical constants:</p>
    <ul>
        <li><code>Math.PI</code> - Represents the value of π (3.14159...)</li>
        <li><code>Math.E</code> - Represents the base of natural logarithms (2.718...)</li>
    </ul>

    <h4>Example: Using Math Constants</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println("Value of PI: " + Math.PI);
        System.out.println("Value of E: " + Math.E);
    }
}</code></pre>

    <h3>2. Basic Mathematical Operations</h3>
    <p>The <code>Math</code> class provides methods for common mathematical operations:</p>
    <ul>
        <li><code>Math.abs(x)</code> - Returns the absolute value of <code>x</code></li>
        <li><code>Math.max(a, b)</code> - Returns the maximum of <code>a</code> and <code>b</code></li>
        <li><code>Math.min(a, b)</code> - Returns the minimum of <code>a</code> and <code>b</code></li>
        <li><code>Math.sqrt(x)</code> - Returns the square root of <code>x</code></li>
        <li><code>Math.pow(x, y)</code> - Returns <code>x</code> raised to the power of <code>y</code></li>
        <li><code>Math.round(x)</code> - Rounds <code>x</code> to the nearest integer</li>
        <li><code>Math.floor(x)</code> - Rounds <code>x</code> down to the nearest whole number</li>
        <li><code>Math.ceil(x)</code> - Rounds <code>x</code> up to the nearest whole number</li>
    </ul>

    <h4>Example: Performing Math Operations</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println("Absolute value of -5: " + Math.abs(-5));
        System.out.println("Maximum of 10 and 20: " + Math.max(10, 20));
        System.out.println("Minimum of 10 and 20: " + Math.min(10, 20));
        System.out.println("Square root of 16: " + Math.sqrt(16));
        System.out.println("2 to the power of 3: " + Math.pow(2, 3));
        System.out.println("Rounded value of 4.6: " + Math.round(4.6));
        System.out.println("Floor value of 4.9: " + Math.floor(4.9));
        System.out.println("Ceil value of 4.1: " + Math.ceil(4.1));
    }
}</code></pre>

    <h3>3. Trigonometric Functions</h3>
    <p>The <code>Math</code> class provides functions for trigonometric calculations:</p>
    <ul>
        <li><code>Math.sin(x)</code> - Returns the sine of <code>x</code> (in radians)</li>
        <li><code>Math.cos(x)</code> - Returns the cosine of <code>x</code></li>
        <li><code>Math.tan(x)</code> - Returns the tangent of <code>x</code></li>
        <li><code>Math.toRadians(deg)</code> - Converts degrees to radians</li>
        <li><code>Math.toDegrees(rad)</code> - Converts radians to degrees</li>
    </ul>

    <h4>Example: Using Trigonometric Functions</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        double angle = 45;
        double radians = Math.toRadians(angle);

        System.out.println("Sine of 45 degrees: " + Math.sin(radians));
        System.out.println("Cosine of 45 degrees: " + Math.cos(radians));
        System.out.println("Tangent of 45 degrees: " + Math.tan(radians));
    }
}</code></pre>

    <h3>4. Generating Random Numbers</h3>
    <p>The <code>Math.random()</code> method generates a random decimal number between <code>0.0</code> (inclusive) and <code>1.0</code> (exclusive).</p>

    <h4>Example: Generating Random Numbers</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println("Random number between 0 and 1: " + Math.random());
        
        // Generate a random number between 1 and 100
        int randomNum = (int) (Math.random() * 100) + 1;
        System.out.println("Random number between 1 and 100: " + randomNum);
    }
}</code></pre>

    <p>The <code>Math</code> class provides a powerful set of functions for performing mathematical calculations in Java. </p>
</section>

        <section id="packages" class="lesson">
    <h2>Understanding Packages in Java</h2>

    <p>In Java, a <strong>package</strong> is a way to organize classes and interfaces into namespaces, helping manage large projects by grouping related code together. It also helps prevent naming conflicts and provides access control.</p>

    <h3>1. What Are Packages?</h3>
    <p>A package is a collection of related classes and interfaces. Java provides two types of packages:</p>
    <ul>
        <li><strong>Built-in packages:</strong> Predefined packages provided by Java (e.g., <code>java.util</code>, <code>java.io</code>).</li>
        <li><strong>User-defined packages:</strong> Custom packages created by developers.</li>
    </ul>

    <h3>2. Using Built-in Packages</h3>
    <p>Java comes with many built-in packages that provide useful functionality. You can import and use them in your program.</p>

    <h4>Example: Using the <code>java.util</code> Package</h4>
    <pre><code>import java.util.Scanner; // Import Scanner class

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter your name: ");
        String name = scanner.nextLine();
        System.out.println("Hello, " + name + "!");
    }
}</code></pre>

    <h3>3. Creating a User-Defined Package</h3>
    <p>To create a package, use the <code>package</code> keyword at the beginning of your Java file.</p>

    <h4>Example: Creating a Custom Package</h4>
    <p>Step 1: Create a package and save the file inside it.</p>
    <pre><code>// File: MyPackage/MyClass.java
package MyPackage;

public class MyClass {
    public void displayMessage() {
        System.out.println("Hello from MyPackage!");
    }
}</code></pre>

    <p>Step 2: Use the custom package in another Java file.</p>
    <pre><code>// File: Main.java
import MyPackage.MyClass;

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.displayMessage();
    }
}</code></pre>

    <h3>4. Access Control in Packages</h3>
    <p>Packages help control access to classes and methods using access modifiers:</p>
    <ul>
        <li><code>public</code> - Accessible from anywhere.</li>
        <li><code>private</code> - Accessible only within the same class.</li>
        <li><code>protected</code> - Accessible within the same package and subclasses.</li>
        <li><code>default</code> (no modifier) - Accessible only within the same package.</li>
    </ul>

    <h4>Example: Access Control</h4>
    <pre><code>package MyPackage;

public class MyClass {
    private String message = "This is private";

    public void showMessage() {
        System.out.println(message);
    }
}</code></pre>

    <p>Trying to access <code>message</code> from another class will result in an error because it's private.</p>

    <h3>5. Importing Packages</h3>
    <p>To use a package, import it using one of the following:</p>
    <ul>
        <li><code>import package_name.ClassName;</code> (Imports a specific class)</li>
        <li><code>import package_name.*;</code> (Imports all classes in a package)</li>
    </ul>

    <h4>Example: Importing All Classes</h4>
    <pre><code>import MyPackage.*;

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.displayMessage();
    }
}</code></pre>

    <p>Packages help keep Java projects organized and modular.</p>
</section>

        <section id="overriding-overloading" class="lesson">
    <h2>Method Overriding and Method Overloading in Java</h2>

    <p>Java allows methods to have the same name but different behaviors. This can be achieved through <strong>method overriding</strong> and <strong>method overloading</strong>. Both concepts help improve code reusability and flexibility.</p>

    <h3>1. Method Overriding</h3>
    <p>Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method in the subclass must have the same name, return type, and parameters as the method in the superclass.</p>

    <h4>Rules for Overriding:</h4>
    <ul>
        <li>The method must have the same signature (name and parameters) as the superclass method.</li>
        <li>The method must be in a subclass (inheritance is required).</li>
        <li>The access level of the overridden method cannot be more restrictive than the superclass method.</li>
        <li><code>@Override</code> annotation is recommended to indicate method overriding.</li>
    </ul>

    <h4>Example: Method Overriding</h4>
    <pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        myAnimal.makeSound(); // Output: Animal makes a sound
        
        Animal myDog = new Dog();
        myDog.makeSound(); // Output: Dog barks
    }
}</code></pre>

    <h3>2. Method Overloading</h3>
    <p>Method overloading occurs when multiple methods in the same class have the same name but different parameters (different number or type of parameters).</p>

    <h4>Rules for Overloading:</h4>
    <ul>
        <li>Methods must have the same name but different parameters.</li>
        <li>It can occur in the same class or in a subclass.</li>
        <li>The return type may be different, but it is not enough to differentiate overloaded methods.</li>
    </ul>

    <h4>Example: Method Overloading</h4>
    <pre><code>class MathOperations {
    // Overloaded method with two integers
    int add(int a, int b) {
        return a + b;
    }

    // Overloaded method with three integers
    int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded method with double values
    double add(double a, double b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        MathOperations math = new MathOperations();
        
        System.out.println("Sum of 2 and 3: " + math.add(2, 3));
        System.out.println("Sum of 2, 3, and 4: " + math.add(2, 3, 4));
        System.out.println("Sum of 2.5 and 3.5: " + math.add(2.5, 3.5));
    }
}</code></pre>

    <h3>3. Differences Between Overriding and Overloading</h3>
    <table border="1">
        <tr>
            <th>Feature</th>
            <th>Method Overriding</th>
            <th>Method Overloading</th>
        </tr>
        <tr>
            <td>Definition</td>
            <td>Redefining a method from a superclass in a subclass.</td>
            <td>Creating multiple methods with the same name but different parameters.</td>
        </tr>
        <tr>
            <td>Parameters</td>
            <td>Must remain the same.</td>
            <td>Must be different (number, type, or both).</td>
        </tr>
        <tr>
            <td>Return Type</td>
            <td>Must be the same or a subclass (covariant return type).</td>
            <td>Can be different but does not determine overloading.</td>
        </tr>
        <tr>
            <td>Inheritance</td>
            <td>Requires inheritance.</td>
            <td>Can occur within the same class.</td>
        </tr>
        <tr>
            <td>Access Modifier</td>
            <td>Cannot have a more restrictive access level than the superclass method.</td>
            <td>Can have any access modifier.</td>
        </tr>
    </table>

    <h3>4. Real-World Use Cases</h3>
    <ul>
        <li><strong>Overriding:</strong> Used in frameworks where base classes provide generic implementations and subclasses modify behavior.</li>
        <li><strong>Overloading:</strong> Common in utility classes where multiple versions of a method allow different inputs.</li>
    </ul>

    <p>Understanding method overriding and overloading helps create flexible and efficient Java applications.</p>
</section>

        <section id="interfaces" class="lesson">
    <h2>Understanding Interfaces in Java</h2>

    <p>In Java, an <strong>interface</strong> is a blueprint for a class that defines a set of abstract methods but does not provide their implementation. Interfaces help achieve abstraction and multiple inheritance.</p>

    <h3>1. What is an Interface?</h3>
    <p>An interface is similar to a class but only contains method declarations (without a body) and constants. A class that implements an interface must provide concrete implementations for all its methods.</p>

    <h4>Example: Defining an Interface</h4>
    <pre><code>interface Animal {
    void makeSound(); // Abstract method (no body)
}</code></pre>

    <h4>Example: Implementing an Interface</h4>
    <pre><code>class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.makeSound(); // Output: Dog barks
    }
}</code></pre>

    <h3>2. Multiple Inheritance Using Interfaces</h3>
    <p>Java does not support multiple inheritance with classes, but interfaces allow a class to implement multiple behaviors.</p>

    <h4>Example: Implementing Multiple Interfaces</h4>
    <pre><code>interface Animal {
    void eat();
}

interface Pet {
    void play();
}

class Dog implements Animal, Pet {
    @Override
    public void eat() {
        System.out.println("Dog eats");
    }

    @Override
    public void play() {
        System.out.println("Dog plays");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.eat();  // Output: Dog eats
        myDog.play(); // Output: Dog plays
    }
}</code></pre>

    <h3>3. Default and Static Methods in Interfaces</h3>
    <p>Java 8 introduced <code>default</code> and <code>static</code> methods in interfaces to allow method implementations.</p>

    <h4>Example: Default Method</h4>
    <pre><code>interface Animal {
    default void sleep() {
        System.out.println("Animal is sleeping");
    }
}

class Dog implements Animal {
    // Dog inherits the sleep() method from Animal
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.sleep(); // Output: Animal is sleeping
    }
}</code></pre>

    <h4>Example: Static Method</h4>
    <pre><code>interface MathUtils {
    static int square(int x) {
        return x * x;
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(MathUtils.square(5)); // Output: 25
    }
}</code></pre>

    <h3>4. Interface vs Abstract Class</h3>
    <table border="1">
        <tr>
            <th>Feature</th>
            <th>Interface</th>
            <th>Abstract Class</th>
        </tr>
        <tr>
            <td>Method Implementation</td>
            <td>Only abstract methods (until Java 8 introduced default/static methods).</td>
            <td>Can have both abstract and concrete methods.</td>
        </tr>
        <tr>
            <td>Inheritance</td>
            <td>Supports multiple inheritance.</td>
            <td>Only single inheritance.</td>
        </tr>
        <tr>
            <td>Access Modifiers</td>
            <td>Methods are implicitly <code>public</code>.</td>
            <td>Methods can have any access modifier.</td>
        </tr>
        <tr>
            <td>Constructors</td>
            <td>No constructors.</td>
            <td>Can have constructors.</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Defines a contract for multiple classes.</td>
            <td>Used for sharing behavior among closely related classes.</td>
        </tr>
    </table>

    <h3>5. When to Use an Interface?</h3>
    <ul>
        <li>When multiple unrelated classes need to implement the same behavior.</li>
        <li>When achieving multiple inheritance is necessary.</li>
        <li>When you want to define a contract that classes must follow.</li>
    </ul>

    <p>Interfaces are a powerful tool in Java for designing flexible and scalable applications. In the next lesson, we'll explore <strong>Exception Handling</strong> to manage runtime errors effectively!</p>
</section>

        <section id="casting" class="lesson">
    <h2>Understanding Casting in Java</h2>

    <p>Casting in Java is the process of converting one data type into another. It is essential when working with different types of variables, objects, or when implementing polymorphism.</p>

    <h3>1. Types of Casting</h3>
    <p>There are two main types of casting in Java:</p>
    <ul>
        <li><strong>Implicit Casting (Widening Conversion)</strong> - Automatically converts a smaller type to a larger type.</li>
        <li><strong>Explicit Casting (Narrowing Conversion)</strong> - Requires manual conversion from a larger type to a smaller type.</li>
    </ul>

    <h3>2. Implicit Casting (Widening)</h3>
    <p>Occurs when a smaller data type is automatically converted to a larger data type.</p>

    <h4>Example: Widening Conversion</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        int num = 10;
        double doubleNum = num; // Implicit casting from int to double
        System.out.println("Integer: " + num);
        System.out.println("Double: " + doubleNum);
    }
}</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code>Integer: 10
Double: 10.0</code></pre>

    <h3>3. Explicit Casting (Narrowing)</h3>
    <p>Occurs when a larger data type is manually converted into a smaller data type.</p>

    <h4>Example: Narrowing Conversion</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        double doubleNum = 9.78;
        int num = (int) doubleNum; // Explicit casting from double to int
        System.out.println("Double: " + doubleNum);
        System.out.println("Integer: " + num);
    }
}</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code>Double: 9.78
Integer: 9</code></pre>

    <h3>4. Casting Objects (Upcasting and Downcasting)</h3>
    <p>In Java, object casting is used when dealing with inheritance and polymorphism.</p>

    <h4>Upcasting (Implicit)</h4>
    <p>Upcasting is converting a subclass object into a superclass reference. This happens automatically.</p>
    <pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // Upcasting (Implicit)
        myAnimal.makeSound();
        // myAnimal.bark(); // Error! Cannot access Dog-specific method
    }
}</code></pre>

    <h4>Downcasting (Explicit)</h4>
    <p>Downcasting is converting a superclass reference back into a subclass reference. This requires explicit casting.</p>

    <pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // Upcasting
        Dog myDog = (Dog) myAnimal;  // Downcasting (Explicit)
        myDog.bark(); // Now we can access Dog-specific methods
    }
}</code></pre>

    <h3>5. The <code>instanceof</code> Operator</h3>
    <p>Before performing downcasting, it's good practice to check if an object is an instance of a specific class.</p>

    <h4>Example: Using <code>instanceof</code></h4>
    <pre><code>if (myAnimal instanceof Dog) {
    Dog myDog = (Dog) myAnimal;
    myDog.bark();
}</code></pre>

    <h3>6. When to Use Casting?</h3>
    <ul>
        <li><strong>Widening</strong> - When converting a smaller primitive type to a larger type.</li>
        <li><strong>Narrowing</strong> - When converting a larger primitive type to a smaller type.</li>
        <li><strong>Upcasting</strong> - When treating a subclass object as a superclass reference (common in polymorphism).</li>
        <li><strong>Downcasting</strong> - When accessing subclass-specific methods from a superclass reference.</li>
    </ul>

    <p>Casting is crucial in Java for handling different data types and objects efficiently. In the next lesson, we'll explore <strong>Exception Handling</strong> to manage runtime errors effectively!</p>
</section>

        <section id="anonymous-inner-classes" class="lesson">
    <h2>Understanding Anonymous and Inner Classes in Java</h2>

    <p>In Java, classes can be defined inside other classes, known as <strong>inner classes</strong>. Java also supports <strong>anonymous classes</strong>, which allow you to create a one-time-use class without explicitly defining it.</p>

    <h3>1. What is an Inner Class?</h3>
    <p>An <strong>inner class</strong> is a class defined within another class. Inner classes help in logically grouping classes that are only used inside their enclosing class.</p>

    <h4>Example: Regular Inner Class</h4>
    <pre><code>class OuterClass {
    private String message = "Hello from Outer Class!";

    class InnerClass {
        void display() {
            System.out.println(message); // Accessing outer class variable
        }
    }
}

public class Main {
    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass(); // Creating inner class object
        inner.display();
    }
}</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code>Hello from Outer Class!</code></pre>

    <h3>2. Static Inner Class</h3>
    <p>A static inner class can be created without an instance of the outer class.</p>

    <h4>Example: Static Inner Class</h4>
    <pre><code>class OuterClass {
    static class StaticInner {
        void display() {
            System.out.println("Hello from Static Inner Class!");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        OuterClass.StaticInner inner = new OuterClass.StaticInner(); // No outer class instance needed
        inner.display();
    }
}</code></pre>

    <h3>3. What is an Anonymous Class?</h3>
    <p>An <strong>anonymous class</strong> is a class without a name, typically used to provide an immediate implementation of an interface or override a method of a superclass.</p>

    <h4>Example: Anonymous Class Implementing an Interface</h4>
    <pre><code>interface Greeting {
    void sayHello();
}

public class Main {
    public static void main(String[] args) {
        Greeting greeting = new Greeting() { // Anonymous class
            @Override
            public void sayHello() {
                System.out.println("Hello from Anonymous Class!");
            }
        };
        greeting.sayHello();
    }
}</code></pre>

    <h4>Example: Anonymous Class Extending a Class</h4>
    <pre><code>abstract class Animal {
    abstract void makeSound();
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Animal() { // Anonymous class
            @Override
            void makeSound() {
                System.out.println("Dog barks!");
            }
        };
        dog.makeSound();
    }
}</code></pre>

    <h3>4. When to Use Inner and Anonymous Classes?</h3>
    <ul>
        <li><strong>Inner classes</strong> - When logically grouping classes that should be used within an outer class.</li>
        <li><strong>Static inner classes</strong> - When an inner class doesn’t need access to an outer class instance.</li>
        <li><strong>Anonymous classes</strong> - When creating short-lived, one-time-use objects that implement an interface or extend a class.</li>
    </ul>

    <p>Inner and anonymous classes help make Java code more organized and concise. </p>
</section>

        <section id="equals-method" class="lesson">
    <h2>Understanding the <code>equals()</code> Method in Java</h2>

    <p>In Java, the <code>equals()</code> method is used to compare objects for equality. It is defined in the <code>Object</code> class and can be overridden to provide custom comparison logic.</p>

    <h3>1. Default Behavior of <code>equals()</code></h3>
    <p>By default, the <code>equals()</code> method checks if two object references point to the same memory location (i.e., it behaves like <code>==</code>).</p>

    <h4>Example: Default <code>equals()</code> Method</h4>
    <pre><code>class Person {
    String name;

    Person(String name) {
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        System.out.println(p1.equals(p2)); // Output: false (different memory locations)
    }
}</code></pre>

    <h3>2. Overriding <code>equals()</code></h3>
    <p>To compare the contents of objects instead of memory references, we need to override <code>equals()</code>.</p>

    <h4>Example: Overriding <code>equals()</code></h4>
    <pre><code>class Person {
    String name;

    Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("Alice");
        Person p2 = new Person("Alice");

        System.out.println(p1.equals(p2)); // Output: true
    }
}</code></pre>

    <h3>3. <code>equals()</code> vs <code>==</code></h3>
    <table border="1">
        <tr>
            <th>Comparison</th>
            <th><code>==</code></th>
            <th><code>equals()</code></th>
        </tr>
        <tr>
            <td>Comparison Type</td>
            <td>Checks if two references point to the same object.</td>
            <td>Compares the contents of the objects (when overridden).</td>
        </tr>
        <tr>
            <td>Used For</td>
            <td>Comparing primitive types and memory references.</td>
            <td>Comparing object contents.</td>
        </tr>
        <tr>
            <td>Example</td>
            <td><code>str1 == str2</code> (compares memory addresses)</td>
            <td><code>str1.equals(str2)</code> (compares string values)</td>
        </tr>
    </table>

    <h3>4. Using <code>equals()</code> with Strings</h3>
    <p>The <code>String</code> class overrides <code>equals()</code> to compare values instead of references.</p>

    <h4>Example: Comparing Strings</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        String s1 = new String("Java");
        String s2 = new String("Java");

        System.out.println(s1 == s2); // Output: false (different memory locations)
        System.out.println(s1.equals(s2)); // Output: true (same content)
    }
}</code></pre>

    <h3>5. Best Practices for Overriding <code>equals()</code></h3>
    <ul>
        <li>Check if the object is being compared with itself (<code>this == obj</code>).</li>
        <li>Check for <code>null</code> and class type compatibility.</li>
        <li>Cast the object to the correct type before comparison.</li>
        <li>Compare all relevant fields for equality.</li>
    </ul>

    <p>Understanding <code>equals()</code> is essential for correctly comparing objects in Java.</p>
</section>

        <section id="enums" class="lesson">
    <h2>Understanding Enums in Java</h2>

    <p>In Java, an <strong>enum</strong> (short for "enumeration") is a special data type used to define a fixed set of constants. Enums help make the code more readable and prevent invalid values.</p>

    <h3>1. Defining an Enum</h3>
    <p>An enum is defined using the <code>enum</code> keyword. Each constant inside an enum is implicitly <code>public</code>, <code>static</code>, and <code>final</code>.</p>

    <h4>Example: Creating an Enum</h4>
    <pre><code>enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}

public class Main {
    public static void main(String[] args) {
        Day today = Day.WEDNESDAY;
        System.out.println("Today is: " + today);
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Today is: WEDNESDAY</code></pre>

    <h3>2. Using Enums in a Switch Statement</h3>
    <p>Enums work well with <code>switch</code> statements.</p>

    <h4>Example: Enum in a Switch Statement</h4>
    <pre><code>enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}

public class Main {
    public static void main(String[] args) {
        Day today = Day.FRIDAY;

        switch (today) {
            case MONDAY:
                System.out.println("Start of the week!");
                break;
            case FRIDAY:
                System.out.println("Weekend is near!");
                break;
            case SUNDAY:
                System.out.println("It's a rest day!");
                break;
            default:
                System.out.println("A regular day.");
        }
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Weekend is near!</code></pre>

    <h3>3. Enum with Fields and Methods</h3>
    <p>Enums can also have fields, constructors, and methods.</p>

    <h4>Example: Enum with Fields and Methods</h4>
    <pre><code>enum Size {
    SMALL(30), MEDIUM(50), LARGE(70);

    private int price;

    Size(int price) {
        this.price = price;
    }

    public int getPrice() {
        return price;
    }
}

public class Main {
    public static void main(String[] args) {
        Size mySize = Size.MEDIUM;
        System.out.println("Size: " + mySize + ", Price: $" + mySize.getPrice());
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Size: MEDIUM, Price: $50</code></pre>

    <h3>4. Looping Through Enum Values</h3>
    <p>You can loop through all enum values using the <code>values()</code> method.</p>

    <h4>Example: Iterating Over Enum Values</h4>
    <pre><code>enum Color {
    RED, GREEN, BLUE
}

public class Main {
    public static void main(String[] args) {
        for (Color c : Color.values()) {
            System.out.println(c);
        }
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>RED
GREEN
BLUE</code></pre>

    <h3>5. When to Use Enums?</h3>
    <ul>
        <li>When you have a fixed set of values (e.g., days of the week, sizes, directions).</li>
        <li>To improve code readability and maintainability.</li>
        <li>To prevent invalid values from being assigned to a variable.</li>
    </ul>

    <p>Enums are a powerful tool in Java for representing constant values in a clear and structured way.</p>
</section>

        <section id="exception-handling" class="lesson">
    <h2>Understanding Exception Handling in Java</h2>

    <p>In Java, an <strong>exception</strong> is an event that disrupts the normal flow of a program. Exception handling allows developers to manage errors gracefully and prevent crashes.</p>

    <h3>1. What is an Exception?</h3>
    <p>An exception occurs when a program encounters an error during execution, such as dividing by zero or accessing an invalid array index. Java provides a structured way to handle these errors using <code>try</code>, <code>catch</code>, and <code>finally</code> blocks.</p>

    <h3>2. Handling Exceptions with <code>try</code> and <code>catch</code></h3>
    <p>The <code>try</code> block contains the code that may throw an exception, while the <code>catch</code> block handles the exception.</p>

    <h4>Example: Handling an Arithmetic Exception</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        try {
            int result = 10 / 0; // This will throw an exception
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.out.println("Error: Cannot divide by zero.");
        }
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Error: Cannot divide by zero.</code></pre>

    <h3>3. Using Multiple <code>catch</code> Blocks</h3>
    <p>Java allows multiple <code>catch</code> blocks to handle different types of exceptions.</p>

    <h4>Example: Handling Multiple Exceptions</h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3};
            System.out.println(numbers[5]); // This will throw an exception
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Error: Index out of bounds.");
        } catch (Exception e) {
            System.out.println("General error occurred.");
        }
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Error: Index out of bounds.</code></pre>

    <h3>4. The <code>finally</code> Block</h3>
    <p>The <code>finally</code> block always executes, regardless of whether an exception occurs or not. It is used for cleanup operations like closing files or releasing resources.</p>

    <h4>Example: Using <code>finally</code></h4>
    <pre><code>public class Main {
    public static void main(String[] args) {
        try {
            int num = 10 / 2;
            System.out.println("Result: " + num);
        } catch (Exception e) {
            System.out.println("An error occurred.");
        } finally {
            System.out.println("Execution completed.");
        }
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Result: 5
Execution completed.</code></pre>

    <h3>5. Throwing Exceptions with <code>throw</code></h3>
    <p>The <code>throw</code> keyword allows you to create and throw exceptions manually.</p>

    <h4>Example: Throwing an Exception</h4>
    <pre><code>public class Main {
    public static void checkAge(int age) {
        if (age < 18) {
            throw new IllegalArgumentException("Age must be 18 or older.");
        } else {
            System.out.println("Access granted.");
        }
    }

    public static void main(String[] args) {
        checkAge(16); // This will throw an exception
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Exception in thread "main" java.lang.IllegalArgumentException: Age must be 18 or older.</code></pre>

    <h3>6. Declaring Exceptions with <code>throws</code></h3>
    <p>The <code>throws</code> keyword is used in method signatures to declare exceptions that a method might throw.</p>

    <h4>Example: Using <code>throws</code></h4>
    <pre><code>import java.io.*;

public class Main {
    public static void readFile() throws IOException {
        FileReader file = new FileReader("test.txt");
        file.read();
        file.close();
    }

    public static void main(String[] args) {
        try {
            readFile();
        } catch (IOException e) {
            System.out.println("Error reading file.");
        }
    }
}</code></pre>

    <p><strong>Output:</strong></p>
    <pre><code>Error reading file.</code></pre>

    <h3>7. Best Practices for Exception Handling</h3>
    <ul>
        <li>Use specific exception types in <code>catch</code> blocks instead of generic <code>Exception</code>.</li>
        <li>Always clean up resources in a <code>finally</code> block or use try-with-resources.</li>
        <li>Do not suppress exceptions—log them or rethrow them when necessary.</li>
        <li>Use <code>throw</code> and <code>throws</code> appropriately for custom exceptions.</li>
    </ul>

    <p>Exception handling is crucial for building robust Java applications.</p>
</section>

        <section id="file-handling" class="lesson">
    <h2>File Handling in Java</h2>

    <p>File handling allows Java programs to read from and write to files, enabling data storage and retrieval. Java provides the <code>java.io</code> and <code>java.nio</code> packages for working with files.</p>

    <h3>1. Reading a File Using <code>FileReader</code></h3>
    <p>The <code>FileReader</code> class is used to read the contents of a text file.</p>

    <h4>Example: Reading a File</h4>
    <pre><code>import java.io.FileReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            FileReader reader = new FileReader("example.txt");
            int character;
            while ((character = reader.read()) != -1) {
                System.out.print((char) character);
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("Error reading the file: " + e.getMessage());
        }
    }
}</code></pre>

    <h3>2. Writing to a File Using <code>FileWriter</code></h3>
    <p>The <code>FileWriter</code> class allows writing data to a file.</p>

    <h4>Example: Writing to a File</h4>
    <pre><code>import java.io.FileWriter;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("example.txt");
            writer.write("Hello, Java File Handling!");
            writer.close();
            System.out.println("File written successfully.");
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
        }
    }
}</code></pre>

    <h3>3. Reading a File Using <code>BufferedReader</code></h3>
    <p>The <code>BufferedReader</code> class reads text from a file efficiently.</p>

    <h4>Example: Using <code>BufferedReader</code></h4>
    <pre><code>import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("example.txt"));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("Error reading the file: " + e.getMessage());
        }
    }
}</code></pre>

    <h3>4. Appending to a File</h3>
    <p>You can append text to an existing file by setting <code>append</code> mode in <code>FileWriter</code>.</p>

    <h4>Example: Appending Data</h4>
    <pre><code>import java.io.FileWriter;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("example.txt", true);
            writer.write("\nAppending new content.");
            writer.close();
            System.out.println("Data appended successfully.");
        } catch (IOException e) {
            System.out.println("Error appending to file: " + e.getMessage());
        }
    }
}</code></pre>

    <h3>5. Deleting a File</h3>
    <p>Use the <code>File</code> class to delete files.</p>

    <h4>Example: Deleting a File</h4>
    <pre><code>import java.io.File;

public class Main {
    public static void main(String[] args) {
        File file = new File("example.txt");
        if (file.delete()) {
            System.out.println("File deleted successfully.");
        } else {
            System.out.println("File deletion failed.");
        }
    }
}</code></pre>

    <h3>6. Best Practices for File Handling</h3>
    <ul>
        <li>Always close file resources using <code>close()</code> or try-with-resources.</li>
        <li>Handle <code>IOException</code> properly to prevent crashes.</li>
        <li>Use <code>BufferedReader</code> for efficient file reading.</li>
    </ul>

    <p>File handling is essential for managing external data in Java applications.</p>
</section>
    </main>

    <!-- Footer -->
    <footer class="footer">
      <div class="footer-container">
        
        <!-- Contact Info -->
        <div class="footer-section">
          <h3>Contact Us</h3>
          <p>Email: support@learnhub.dev</p>
          <p>Phone: +1 (123) 456-7890</p>
        </div>
        
        <!-- Center Title -->
        <div class="footer-title">
          <h2><span class="blue">Learning</span><span class="orange">Hub</span></h2>
          <p>Your gateway to programming mastery</p>
        </div>
        
        <div class="footer-section">
          <h4>Explore More</h4>
          <ul>
            <li><a href="https://www.freecodecamp.org" target="_blank">FreeCodeCamp</a></li>
            <li><a href="https://www.codecademy.com" target="_blank">Codecademy</a></li>
            <li><a href="https://www.udemy.com" target="_blank">Udemy</a></li>
            <li><a href="https://www.coursera.org" target="_blank">Coursera</a></li>
          </ul>
        </div>
        
        
      </div>
      <p class="copyright">© 2025 LearnHub. All rights reserved.</p>
    </footer>
    <script defer src="script.js"></script>

</body>
</html>